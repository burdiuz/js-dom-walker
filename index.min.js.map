{"version":3,"file":"index.min.js","sources":["node_modules/@actualwave/tree-walker/dist/tree-walker.js","node_modules/@actualwave/walker-browserdom-adapter/index.js","node_modules/@actualwave/walker-browserdom-augmentations/index.js","node_modules/@actualwave/walker-property-handlers/index.js","source/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nlet defaultAdapter;\n\nconst setDefaultAdapter = adapter => {\n  defaultAdapter = adapter;\n};\nconst getDefaultAdapter = () => defaultAdapter;\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar hasOwn_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;\n});\n\nvar hasOwn = unwrapExports(hasOwn_1);\nvar hasOwn_2 = hasOwn_1.hasOwn;\n\nconst GET_KEY = 'get';\nconst HAS_KEY = 'has';\nconst SET_KEY = 'set';\nconst DELETE_KEY = 'deleteProperty';\n\nconst namePrefixes = {};\n\nconst isValidPrefix = prefix => typeof prefix === 'string' && hasOwn(namePrefixes, prefix);\n\nconst getPrefix = key => key.charAt();\n\nconst isPrefixedKey = key => {\n  if (key && typeof key === 'string' && key.length > 1) {\n    return hasOwn(namePrefixes, getPrefix(key));\n  }\n\n  return false;\n};\n\nconst getPrefixHandlers = key => namePrefixes[getPrefix(key)];\n\nconst createPrefixHandlerGetter = type => key => {\n  const handlers = getPrefixHandlers(key);\n\n  return handlers && handlers[type];\n};\n\nconst getPrefixGetHandler = createPrefixHandlerGetter(GET_KEY);\n\nconst getPrefixHasHandler = createPrefixHandlerGetter(HAS_KEY);\n\nconst getPrefixSetHandler = createPrefixHandlerGetter(SET_KEY);\n\nconst getPrefixDeleteHandler = createPrefixHandlerGetter(DELETE_KEY);\n\nconst setNamePrefix = (prefix, handler) => {\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\n    throw new Error('Name Prefix must be one character string.');\n  }\n\n  if (typeof handler === 'function') {\n    namePrefixes[prefix] = {\n      get: handler,\n      has: (...args) => handler(...args) !== undefined\n    };\n  } else {\n    const { get, set, has, deleteProperty } = handler;\n\n    namePrefixes[prefix] = { get, set, has, deleteProperty };\n  }\n};\n\nconst isIntKey = key => typeof key === 'number' && key >>> 0 === key ||\n// it is integer number string\n`${parseInt(String(key), 10)}` === key;\n\nconst getValue = (node, adapter, childName = undefined) => {\n  if (childName !== undefined) {\n    return adapter.getChildrenByName(node, childName);\n  }\n\n  return node;\n};\n\nconst getSingleNode = (node, adapter, childName = undefined) => adapter.toNode(getValue(node, adapter, childName));\n\nconst getNodeList = (node, adapter, childName = undefined) => adapter.toList(getValue(node, adapter, childName));\n\nlet augmentations = {};\n\nconst resetAugmentations = (augs = {}) => {\n  augmentations = augs;\n};\n\nconst addAugmentations = augs => {\n  augmentations = Object.assign({}, augmentations, augs);\n};\n\nconst hasAugmentation = key => key && typeof key === 'string' && hasOwn(augmentations, key);\n\nconst applyAugmentation = (key, ...args) => augmentations[key](...args);\n\nlet handlers;\nlet utils;\n\nconst GET_RESTRICTED_NAMES = {\n  constructor: true,\n  prototype: true\n  /*\n  call: true,\n  apply: true,\n  */\n};\n\nconst createWalkerNode = (node, adapter, childName = undefined) => {\n  function TreeWalker() {\n    throw new Error('Should have been never called');\n  }\n\n  // can be single Node and NodeList with length >= 0\n  // should it be always NodeList?\n  TreeWalker.node = node;\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\n  // INFO \"name\" is RO property of Function object\n  TreeWalker.childName = childName;\n  TreeWalker.adapter = adapter;\n  return TreeWalker;\n};\n\nconst wrap = (node, adapter, childName = undefined) => {\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\n    return node;\n  }\n\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\n};\n\n// eslint-disable-next-line\nutils = {\n  isIntKey,\n  getValue,\n  getSingleNode,\n  getNodeList,\n  wrap\n};\n\nconst throwHandlerNotAvailable = (operation, key, handler) => {\n  if (!handler) {\n    throw new Error(`Operation \"${operation}\" is not supported for prefix \"${getPrefix(key)}\".`);\n  }\n};\n\nconst get = ({ node, adapter, childName }, key) => {\n  /*\n   if symbol, return node property\n   if string childName used\n   if starts with prefix, call GET handler\n   else return wrapper with current single node and property childName\n   if numeric index used, use node as parent and childName is undefined\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return getSingleNode(node, adapter, childName)[key];\n  }\n\n  if (isIntKey(key)) {\n    return wrap(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixGetHandler(key);\n\n    throwHandlerNotAvailable(GET_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  const result = getValue(node, adapter, childName);\n\n  // return wrap with node and childName\n  return wrap(result, adapter, key);\n};\n\nconst has = ({ node, adapter, childName }, key) => {\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return key in getSingleNode(node, adapter, childName);\n  }\n\n  if (isIntKey(key)) {\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixHasHandler(key);\n\n    throwHandlerNotAvailable(HAS_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  return adapter.hasChild(getSingleNode(node, adapter, childName), key);\n};\n\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\n  if (childName === undefined) {\n    throw new Error('Cannot call on TreeWalker Node');\n  }\n\n  /* GET always return result of prefixed property, means there are\n     no cases when we get a wrapped node to APPLY trap with prefixed name.\n   if (isValidPrefix(childName)) {\n    const handler = getPrefixApplyHandler(childName);\n     throwHandlerNotAvailable(APPLY_KEY, childName, handler);\n     return handler(\n      node,\n      adapter,\n      [childName.substr(1), ...argumentsList],\n      utils,\n    );\n  }\n  */\n\n  if (hasAugmentation(childName)) {\n    // INFO cannot use target because it contains method's childName, not Node childName\n    // call the function with saving context, so other augmentations are accessible via \"this\"\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\n  }\n\n  // in case of normal function being called out of the tree node\n  const targetNode = adapter.toNode(node);\n  if (typeof targetNode[childName] === 'function') {\n    return targetNode[childName](...argumentsList);\n  }\n\n  // FIXME might throw only in dev mode(needs implementation)\n  throw new Error(`\"${childName}\" is not a callable object.`);\n};\n\nconst set = ({ node, adapter, childName }, key, value) => {\n  /*\n   if symbol, set value directly\n   if starts with prefix, call SET handler\n   else throw an error\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    getSingleNode(node, adapter, childName)[key] = value;\n    return true;\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixSetHandler(key);\n\n    throwHandlerNotAvailable(SET_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1), value], utils);\n  }\n\n  throw new Error(`Operation \"${SET_KEY}\" is not supported for nodes.`);\n};\n\nconst deleteProperty = ({ node, adapter, childName }, key) => {\n  /*\n   if symbol, delete value directly\n   if starts with prefix, call DELETE handler\n   else throw an error\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return delete getSingleNode(node, adapter, childName)[key];\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixDeleteHandler(key);\n\n    throwHandlerNotAvailable(DELETE_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  throw new Error(`Operation \"${DELETE_KEY}\" is not supported for nodes.`);\n};\n\nhandlers = {\n  get,\n  has,\n  apply,\n  // only for prefixed keys\n  set,\n  deleteProperty\n};\n\nconst toString = (node, adapter) => adapter.string ? adapter.string(node) : node.toString();\nconst valueOf = (node, adapter) => adapter.value ? adapter.value(node) : node;\n\nvar coreAugmentations = {\n  toString,\n  valueOf\n};\n\n/* eslint-disable prefer-spread */\nconst name = (node, adapter) => adapter.getName(node);\n\nconst children = (node, adapter, [childName], utils) => {\n  let list;\n\n  if (childName) {\n    list = adapter.getChildrenByName(node, childName);\n  } else {\n    list = adapter.getChildren(node);\n  }\n\n  return utils.wrap(list, adapter);\n};\n\n/**\n * @internal\n */\nconst descendantsAll = (node, adapter, args, utils) => {\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = list[index];\n    children.push(child);\n    descendants.push.apply(descendants, descendantsAll(child, adapter, args, utils));\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\n/**\n * @internal\n */\nconst descendantsByName = (node, adapter, args, utils) => {\n  const [childName] = args;\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n\n    if (adapter.getName(child) === childName) {\n      children.push(child);\n    }\n\n    descendants.push.apply(descendants, descendantsByName(child, adapter, args, utils));\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\nconst descendants = (node, adapter, args, utils) => {\n  const [childName] = args;\n\n  if (childName) {\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\n  }\n\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\n};\n\nconst childAt = (node, adapter, [index = 0], utils) => utils.wrap(adapter.getChildAt(node, index), adapter);\n\nconst root = (node, adapter, args, utils) => utils.wrap(adapter.getNodeRoot(node), adapter);\n\nconst parent = (node, adapter, args, utils) => utils.wrap(adapter.getNodeParent(node), adapter);\n\nvar node = {\n  name,\n  children,\n  descendants,\n  childAt,\n  root,\n  parent\n};\n\nconst length = (node, adapter) => {\n  if (adapter.isList(node)) {\n    return adapter.getLength(node);\n  }\n\n  if (adapter.isNode(node)) {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst at = (node, adapter, args, utils) => {\n  const [index = 0] = args;\n  let result;\n\n  if (adapter.isList(node)) {\n    const child = adapter.getNodeAt(node, index);\n\n    if (child) {\n      result = child;\n    }\n  } else if (!index) {\n    result = node;\n  }\n\n  // if nothing found return empty array, which will create empty wrapper for\n  // chained calls, this will make next calls errorless.\n  return utils.wrap(result || [], adapter);\n};\n\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\n\nconst filter = (node, adapter, [callback], utils) => {\n  // apply filter on element collection\n  // always return wrapped list\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  const result = [];\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\n      result.push(child);\n    }\n  }\n\n  return utils.wrap(result, adapter);\n};\n\nconst map = (node, adapter, [callback], utils) => {\n  // apply map on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(list);\n  const result = [];\n\n  const wrappedList = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    const childResult = callback(utils.wrap(child, adapter), index, wrappedList);\n    result.push(childResult);\n  }\n\n  // returns normal array because we don't know if all items in result are nodes\n  // and if they are, they will be likely already wrapped\n  return result;\n};\n\nconst reduce = (node, adapter, [callback, result], utils) => {\n  // apply reduce on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  let lastResult = result;\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    lastResult = callback(lastResult, utils.wrap(child, adapter), index, wrappedNode);\n  }\n\n  return lastResult;\n};\n\nvar list = {\n  length,\n  at,\n  first,\n  filter,\n  map,\n  reduce\n};\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) => wrap(adapter.validateRoot(root), adapter);\n\nexports.setDefaultAdapter = setDefaultAdapter;\nexports.getDefaultAdapter = getDefaultAdapter;\nexports.addAugmentations = addAugmentations;\nexports.hasAugmentation = hasAugmentation;\nexports.resetAugmentations = resetAugmentations;\nexports.coreAugmentations = coreAugmentations;\nexports.nodeAugmentations = node;\nexports.listAugmentations = list;\nexports.setNamePrefix = setNamePrefix;\nexports.isValidPrefix = isValidPrefix;\nexports.create = create;\nexports.default = create;\n//# sourceMappingURL=tree-walker.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst adapter = {\n  isList: node => node instanceof Array || node instanceof HTMLCollection || node instanceof NodeList,\n\n  toList: (...args) => {\n    const { length } = args;\n    const [node] = args;\n\n    if (length === 1 && adapter.isList(node)) {\n      return node;\n    }\n\n    const list = [];\n\n    for (let index = 0; index < length; index++) {\n      const part = args[index];\n      if (adapter.isList(part)) {\n        list.push.call(part);\n      } else {\n        list.push(part);\n      }\n    }\n\n    return list;\n  },\n\n  isNode: node => node instanceof HTMLElement,\n\n  toNode: node => {\n    // if list we use only first node\n    if (adapter.isList(node)) {\n      return node.length ? node[0] : null;\n    }\n\n    return adapter.isNode(node) ? node : null;\n  },\n\n  getNodeAt: (list, index = 0) => {\n    if (adapter.isList(list)) {\n      return list[index];\n    }\n\n    return list;\n  },\n\n  getLength: list => {\n    if (!list) return 0;\n    if (adapter.isList(list)) {\n      return list.length;\n    }\n\n    return 1;\n  },\n\n  getName: node => {\n    const target = adapter.toNode(node);\n    return target ? target.nodeName.toLowerCase() : null;\n  },\n\n  // Node\n  getChildren: node => {\n    const parent = adapter.toNode(node);\n\n    // if not a node, return empty list\n    return adapter.isNode(parent) ? parent.children : adapter.toList();\n  },\n\n  getChildrenByName: (node, name) => {\n    const nodeName = name.toLowerCase();\n    const children = adapter.getChildren(node);\n    const { length } = children;\n\n    if (!length) {\n      return children;\n    }\n\n    const list = [];\n\n    for (let index = 0; index < children.length; index++) {\n      const child = children[index];\n      if (adapter.getName(child) === nodeName) {\n        list.push(child);\n      }\n    }\n\n    return list;\n  },\n\n  hasChild: (node, name) => {\n    const children = adapter.getChildren(node);\n    const { length } = children;\n\n    for (let index = 0; index < length; index++) {\n      if (children[index].nodeName === name) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  getChildAt: (node, index) => adapter.getChildren(node)[index],\n\n  getNodeParent: node => adapter.toNode(node).parentNode,\n\n  getNodeRoot: node => adapter.toNode(node).getRootNode(),\n\n  validateRoot: root => {\n    if (root === undefined || root === document) {\n      return document.firstElementChild;\n    }\n\n    if (typeof root === 'string') {\n      return document.querySelector(root);\n    }\n\n    return root;\n  }\n};\n\nexports.default = adapter;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst on = (node, adapter, [eventType, callback]) => {\n  const target = adapter.toNode(node);\n  target.addEventListener(eventType, callback);\n  return () => target.removeEventListener(eventType, callback);\n};\n\nconst off = (node, adapter, [eventType, callback]) => {\n  adapter.toNode(node).removeEventListener(eventType, callback);\n};\n\nconst emmit = (node, adapter, [event]) => {\n  adapter.toNode(node).dispatchEvent(event instanceof Event ? event : new Event(String(event)));\n};\n\nvar event = {\n  on,\n  off,\n  emmit\n};\n\nconst name = (node, adapter) => adapter.getName(node);\n\nconst text = (node, adapter) => adapter.toNode(node).innerText;\n\nconst attributes = (node, adapter) => adapter.toNode(node).attributes;\n\nconst attribute = (node, adapter, args) => {\n  const [name] = args;\n  const target = adapter.toNode(node);\n\n  if (args.length === 2) {\n    const [value] = args;\n\n    if (value === undefined) {\n      target.removeAttribute(name);\n    } else {\n      target.setAttribute(name, value);\n    }\n  }\n\n  return target.getAttribute(name);\n};\n\nconst parent = (node, adapter) => adapter.getParentNode(node);\n\nconst root = (node, adapter) => adapter.getRootNode(node);\n\nconst query = (node, adapter, [queryString], utils) => {\n  const result = adapter.toNode(node).querySelector(queryString);\n  return utils.wrap(adapter.isNode(result) ? result : [], adapter);\n};\n\nconst queryAll = (node, adapter, [queryString], utils) => {\n  const result = adapter.toNode(node).querySelectorAll(queryString);\n  return utils.wrap(result, adapter);\n};\n\nvar element = {\n  name,\n  text,\n  attributes,\n  attribute,\n  parent,\n  root,\n  query,\n  queryAll\n};\n\nexports.eventAugmentations = event;\nexports.elementAugmentations = element;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar hasOwn_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;\n});\n\nvar hasOwn = unwrapExports(hasOwn_1);\nvar hasOwn_2 = hasOwn_1.hasOwn;\n\nconst getHandler = (data, [name]) => data ? data[name] : undefined;\n\nconst hasHandler = (data, [name]) => hasOwn(data, name);\n\nconst setHandler = (data, [name, value]) => {\n  if (!data) {\n    return false;\n  }\n\n  data[name] = value;\n  return true;\n};\n\nconst deletePropertyHandler = (data, [name]) => data ? delete data[name] : false;\n\nconst defaultDataGetter = node => node;\n\nconst preHandler = (getData, handler) => (target, adapter, ...args) => handler(getData(adapter.toNode(target)), ...args);\n\nconst createROHandlers = (getData = defaultDataGetter) => ({\n  get: preHandler(getData, getHandler),\n  has: preHandler(getData, hasHandler)\n});\n\nconst createHandlers = (getData = defaultDataGetter) => Object.assign({}, createROHandlers(getData), {\n  set: preHandler(getData, setHandler),\n  deleteProperty: preHandler(getData, deletePropertyHandler)\n});\n\nexports.createROHandlers = createROHandlers;\nexports.createHandlers = createHandlers;\n//# sourceMappingURL=index.js.map\n","import {\n  setNamePrefix,\n  addAugmentations,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n  create as createRoot,\n} from '@actualwave/tree-walker';\n\nimport BrowserDOMAdapter from '@actualwave/walker-browserdom-adapter';\n\nimport {\n  eventAugmentations,\n  elementAugmentations,\n} from '@actualwave/walker-browserdom-augmentations';\n\nimport { createHandlers } from '@actualwave/walker-property-handlers';\n\naddAugmentations(coreAugmentations);\naddAugmentations({\n  ...nodeAugmentations,\n  descendants: (({ descendants }) => (node, adapter, args, utils) => {\n    const [childName] = args;\n\n    if (childName) {\n      return descendants(node, adapter, [childName.toLowerCase()], utils);\n    }\n\n    return descendants(node, adapter, args, utils);\n  })(nodeAugmentations),\n});\naddAugmentations(listAugmentations);\naddAugmentations(eventAugmentations);\naddAugmentations(elementAugmentations);\n\nsetNamePrefix('$', createHandlers());\n\nconst create = (root, adapter = BrowserDOMAdapter) => createRoot(root, adapter);\n\nexport { addAugmentations, resetAugmentations, setNamePrefix, create };\n\nexport default create;\n"],"names":["defaultAdapter","Object","defineProperty","exports","value","getDefaultAdapter","x","hasOwn_1","fn","module","createCommonjsModule","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","default","__esModule","namePrefixes","getPrefix","key","charAt","isPrefixedKey","length","createPrefixHandlerGetter","type","handlers","getPrefixHandlers","getPrefixGetHandler","getPrefixHasHandler","getPrefixSetHandler","getPrefixDeleteHandler","isIntKey","parseInt","String","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","toNode","getNodeList","toList","augmentations","addAugmentations","augs","assign","hasAugmentation","utils","GET_RESTRICTED_NAMES","constructor","wrap","isNode","isList","Proxy","TreeWalker","Error","createWalkerNode","throwHandlerNotAvailable","operation","handler","get","getNodeAt","substr","result","hasChild","apply","thisArg","argumentsList","args","applyAugmentation","targetNode","set","deleteProperty","coreAugmentations","toString","string","valueOf","descendantsAll","children","descendants","list","getChildren","getLength","index","child","push","descendantsByName","getName","name","childAt","getChildAt","root","getNodeRoot","parent","getNodeParent","at","first","filter","callback","listLength","wrappedNode","map","wrappedList","childResult","reduce","lastResult","create","validateRoot","prefix","Array","HTMLCollection","NodeList","part","HTMLElement","nodeName","toLowerCase","parentNode","getRootNode","document","firstElementChild","querySelector","event","on","eventType","addEventListener","removeEventListener","off","emmit","dispatchEvent","Event","element","text","innerText","attributes","attribute","removeAttribute","setAttribute","getAttribute","getParentNode","query","queryString","queryAll","querySelectorAll","getHandler","data","hasHandler","setHandler","deletePropertyHandler","defaultDataGetter","preHandler","getData","createROHandlers","nodeAugmentations","listAugmentations","eventAugmentations","elementAugmentations","createHandlers","BrowserDOMAdapter","createRoot"],"mappings":"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"}