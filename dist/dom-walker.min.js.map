{"version":3,"file":"dom-walker.min.js","sources":["../node_modules/tree-walker/dist/tree-walker.js","../source/augmentations/event.js","../source/augmentations/element.js","../source/htmlro-adapter.js","../source/index.js","../source/attribute.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nlet defaultAdapter = null;\n\nconst setDefaultAdapter = adapter => {\n  defaultAdapter = adapter;\n};\nconst getDefaultAdapter = () => defaultAdapter;\n\nconst namePrefixes = {};\n\nconst isValidPrefix = prefix => typeof prefix === 'string' && prefix.length === 1 && namePrefixes.hasOwnProperty(prefix);\n\nconst isPrefixedKey = key => key && typeof key === 'string' && key.length > 1 && namePrefixes.hasOwnProperty(key.charAt());\n\nconst getPrefixHandler = key => namePrefixes[key.charAt()];\n\nconst setNamePrefix = (prefix, handler) => {\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\n    throw new Error('Name Prefix must be one character string.');\n  }\n\n  namePrefixes[prefix] = handler;\n};\n\nconst isIntKey = key => `${parseInt(key, 10)}` === key;\n\nconst getValue = (node, adapter, childName = undefined) => {\n  if (childName !== undefined) {\n    return adapter.getChildrenByName(node, childName);\n  }\n\n  return node;\n};\n\nconst getSingleNode = (node, adapter, childName = undefined) => {\n  const value = getValue(node, adapter, childName);\n\n  if (adapter.isList(value)) {\n    return adapter.getNodeAt(node);\n  }\n\n  return value;\n};\n\nconst getNodeList = (node, adapter, childName = undefined) => {\n  return adapter.toList(getValue(node, adapter, childName));\n};\n\nlet augmentations = {};\n\nconst resetAugmentations = (augs = {}) => {\n  augmentations = augs;\n};\n\nconst addAugmentations = (augs = {}) => {\n  augmentations = Object.assign({}, augmentations, augs);\n};\n\nconst hasAugmentation = key => key && typeof key === 'string' && augmentations.hasOwnProperty(key);\n\nconst applyAugmentation = (key, ...args) => augmentations[key](...args);\n\nlet handlers;\nlet utils;\n\nconst createWalkerNode = (node, adapter, childName = undefined) => {\n  function TreeWalker() {\n    throw new Error('should have been never called');\n  }\n\n  // can be single Node and NodeList with length >= 0\n  // should it be always NodeList?\n  TreeWalker.node = node;\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\n  // INFO \"name\" is RO property of Function object\n  TreeWalker.childName = childName;\n  TreeWalker.adapter = adapter;\n  return TreeWalker;\n};\n\nconst wrapWithProxy = (node, adapter, childName = undefined) => {\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\n    return node;\n  }\n\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\n};\n\n// eslint-disable-next-line\nutils = {\n  isIntKey,\n  getValue,\n  getSingleNode,\n  getNodeList,\n  wrapWithProxy\n};\n\nconst get = ({ node, adapter, childName }, key) => {\n  /*\n   if string childName used\n   if starts with $, return attribute value\n   else return wrapper with current single node and property childName\n   if numeric index used, use node as parent and childName is undefined\n   */\n  if (isIntKey(key)) {\n    return wrapWithProxy(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixHandler(key);\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  // return wrap with node and childName\n  return wrapWithProxy(getValue(node, adapter, childName), adapter, key);\n};\n\nconst has = ({ node, adapter, childName }, key) => {\n  if (isIntKey(key)) {\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\n  }\n\n  if (isPrefixedKey(key)) {\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\n    // don't know how to implement this, calling same handler as in GET seems overkill\n    return true;\n  }\n\n  return adapter.hasChild(getSingleNode(), key);\n};\n\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\n  if (childName === undefined) {\n    throw new Error('Cannot call on TreeWalker Node');\n  }\n\n  // this works only of childName === prefix, one char string\n  // otherwise it should be passed into arguments\n  if (isValidPrefix(childName)) {\n    const handler = getPrefixHandler(childName);\n    return handler(node, adapter, argumentsList, utils);\n  }\n\n  if (hasAugmentation(childName)) {\n    // INFO cannot use target because it contains method's childName, not Node childName\n    // call the function with saving context, so other augmentations are accessible via \"this\"\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\n  }\n\n  // FIXME might throw only in dev mode(needs implmentation)\n  throw new Error(`\"${childName}\" is not a callable object.`);\n};\n\nhandlers = {\n  get,\n  has,\n  apply\n};\n\nconst toString = node => node.toString();\nconst valueOf = node => node;\n\nvar coreAugmentations = {\n  toString,\n  valueOf,\n  [Symbol.toPrimitive]: node => node\n};\n\nconst children = (node, adapter, [childName], utils) => {\n  let list;\n\n  if (childName) {\n    list = adapter.getChildrenByName(node, childName);\n  } else {\n    list = adapter.getChildren(node);\n  }\n\n  return utils.wrapWithProxy(list, adapter);\n};\n\nconst childAt = (node, adapter, [index = 0], utils) => utils.wrapWithProxy(adapter.getChildAt(node, index), adapter);\n\nconst root = (node, adapter, args, utils) => utils.wrapWithProxy(adapter.getNodeRoot(node), adapter);\n\nconst parent = (node, adapter, args, utils) => utils.wrapWithProxy(adapter.getNodeParent(node), adapter);\n\nvar node = {\n  children,\n  childAt,\n  root,\n  parent\n};\n\nconst length = (node, adapter) => {\n  if (adapter.isList(node)) {\n    return adapter.getLength(node);\n  } else if (adapter.isNode(node)) {\n    return 1;\n  }\n  return 0;\n};\n\nconst first = (node, adapter, args, utils) => {\n  let result = node;\n\n  if (adapter.isList(node)) {\n    if (node.length) {\n      [result] = node;\n    } else {\n      result = [];\n    }\n  }\n\n  return utils.wrapWithProxy(result, adapter);\n};\n\nconst filter = (node, adapter, [callback], utils) => {\n  // apply filter on element collection\n  // allways return wrapped list\n  node = adapter.toList(node);\n  const list = [];\n\n  const wrappedNode = utils.wrapWithProxy(node, adapter);\n  for (let index = 0; index < node.length; index += 1) {\n    const child = node[index];\n    if (callback(utils.wrapWithProxy(child, adapter), index, wrappedNode)) {\n      list.push(child);\n    }\n  }\n\n  return utils.wrapWithProxy(list, adapter);\n};\n\nconst map = (node, adapter, [callback, wrapNodes = true], utils) => {\n  // apply map on element collection\n  // if wrapNodes in FALSE, will generate normal Array with RAW results in it\n  // if wrapNodes in TRUE and all elements of resulting list are nodes, will\n  //   generate wrapped list and put all result into it\n  node = adapter.toList(node);\n  const list = [];\n\n  let areNodes = true;\n  const wrappedNode = utils.wrapWithProxy(node, adapter);\n  for (let index = 0; index < node.length; index += 1) {\n    const child = node[index];\n    const result = callback(utils.wrapWithProxy(child, adapter), index, wrappedNode);\n    areNodes = areNodes && adapter.isNode(result);\n    list.push(result);\n  }\n\n  return wrapNodes && areNodes ? utils.wrapWithProxy(list, adapter) : list;\n};\n\nconst reduce = (node, adapter, [callback, result], utils) => {\n  // apply reduce on element collection\n  node = adapter.toList(node);\n\n  const wrappedNode = utils.wrapWithProxy(node, adapter);\n  for (let index = 0; index < node.length; index += 1) {\n    const child = node[index];\n    result = callback(result, utils.wrapWithProxy(child, adapter), index, wrappedNode);\n  }\n\n  return result;\n};\n\nvar list = {\n  length,\n  first,\n  filter,\n  map,\n  reduce\n};\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) => wrapWithProxy(adapter.validateRoot(root), adapter);\n\nexports.setDefaultAdapter = setDefaultAdapter;\nexports.getDefaultAdapter = getDefaultAdapter;\nexports.addAugmentations = addAugmentations;\nexports.hasAugmentation = hasAugmentation;\nexports.resetAugmentations = resetAugmentations;\nexports.coreAugmentations = coreAugmentations;\nexports.nodeAugmentations = node;\nexports.listAugmentations = list;\nexports.setNamePrefix = setNamePrefix;\nexports.isValidPrefix = isValidPrefix;\nexports.create = create;\nexports.default = create;\n//# sourceMappingURL=tree-walker.js.map\n","const on = (node, adapter, [eventType, callback]) => {\r\n  node = adapter.toNode(node);\r\n  node.addEventListener(eventType, callback);\r\n  return () => node.removeEventListener(eventType, callback);\r\n};\r\n\r\nconst off = (node, adapter, [eventType, callback]) => {\r\n  adapter\r\n    .toNode(node)\r\n    .removeEventListener(eventType, callback);\r\n};\r\n\r\nconst emmit = (node, adapter, [event]) => {\r\n  adapter\r\n    .toNode(node)\r\n    .dispatchEvent(event instanceof Event ? event : new Event(String(event)));\r\n};\r\n\r\nexport default {\r\n  on,\r\n  off,\r\n  emmit,\r\n};\r\n","const name = (node, adapter) =>\r\n  adapter.getName(node);\r\n\r\nconst text = (node, adapter) =>\r\n  adapter.getText(node);\r\n\r\nconst attributes = (node, adapter) =>\r\n  adapter.getAttributes(node);\r\n\r\nconst query = (node, adapter, [queryString], utils) => {\r\n  const result = adapter.toNode(node).querySelector(queryString);\r\n  return utils.wrapWithProxy(adapter.isNode(result) ? result : [], adapter);\r\n};\r\n\r\nconst queryAll = (node, adapter, [queryString], utils) => {\r\n  const result = adapter.toNode(node).querySelectorAll(queryString);\r\n  return utils.wrapWithProxy(result, adapter);\r\n};\r\n\r\nexport default {\r\n  name,\r\n  text,\r\n  attributes,\r\n  query,\r\n  queryAll,\r\n};\r\n","const isList = (node) => (\r\n  node instanceof Array\r\n  || node instanceof HTMLCollection\r\n  || node instanceof NodeList\r\n);\r\n\r\nconst toList = (...args) => {\r\n  const { length } = args;\r\n  const [node] = args;\r\n\r\n  if (length === 1 && isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    const part = args[index];\r\n    if (isList(part)) {\r\n      list.push.call(part);\r\n    } else {\r\n      list.push(part);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst isNode = (node) => node instanceof HTMLElement;\r\n\r\nconst toNode = (node) => {\r\n  // if list we use only first node\r\n  if (isList(node)) {\r\n    return node.length ? node[0] : null;\r\n  }\r\n\r\n  return isNode(node) ? node : null;\r\n};\r\n\r\nconst getNodeAt = (list, index = 0) => {\r\n  if (isList(list)) {\r\n    return list[index];\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst getLength = (list) => list.length;\r\n\r\n// Node\r\nconst getChildren = (node) => {\r\n  node = toNode(node);\r\n\r\n  // if not a node, return empty list\r\n  return isNode(node) ? node.children : toList();\r\n};\r\n\r\nconst getChildrenByName = (node, name) => {\r\n  name = name.toLowerCase();\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  if (!length) {\r\n    return children;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < children.length; index++) {\r\n    const child = children[index];\r\n    if (child.nodeName.toLowerCase() === name) {\r\n      list.push(child);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst hasChildren = (node) => !!toNode(node).childElementCount;\r\n\r\nconst hasChild = (node, name) => {\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    if (children[index].nodeName === name) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst getChildAt = (node, index) => getChildren(node)[index];\r\n\r\nconst getAttributes = (node) => {\r\n  node = toNode(node);\r\n  if (node.hasAttributes()) {\r\n    return node.attributes;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nconst hasAttribute = (node, name) => toNode(node).hasAttribute(name);\r\n\r\nconst getAttributeValue = (node, name) => toNode(node).getAttribute(name);\r\n\r\nconst getName = (node) => toNode(node).nodeName;\r\n\r\nconst getText = (node) => toNode(node).innerText;\r\n\r\nconst getNodeParent = (node) => toNode(node).parentNode;\r\n\r\nconst getNodeRoot = (node) => toNode(node).getRootNode();\r\n\r\nconst validateRoot = (root) => {\r\n  if (root === undefined || root === document) {\r\n    return document.firstElementChild;\r\n  } else if (typeof root === 'string') {\r\n    return document.querySelector(root);\r\n  }\r\n\r\n  return root;\r\n};\r\n\r\nexport default {\r\n  isList,\r\n  toList,\r\n  isNode,\r\n  toNode,\r\n  getNodeAt,\r\n  getLength,\r\n  getChildren,\r\n  getChildrenByName,\r\n  hasChildren,\r\n  hasChild,\r\n  getChildAt,\r\n  getAttributes,\r\n  hasAttribute,\r\n  getAttributeValue,\r\n  getName,\r\n  getText,\r\n  getNodeParent,\r\n  getNodeRoot,\r\n  validateRoot,\r\n};\r\n","import {\n  setNamePrefix,\n  setDefaultAdapter,\n  addAugmentations,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n  create as createRoot,\n} from 'tree-walker';\n\nimport htmlEventAugmentations from './augmentations/event';\nimport htmlElementAugmentations from './augmentations/element';\n\nimport HTMLROAdapter from './htmlro-adapter';\n\nimport { ATTRIBUTE_KEY, getAttribute } from './attribute';\n\nsetDefaultAdapter(HTMLROAdapter);\n\naddAugmentations(coreAugmentations);\naddAugmentations(nodeAugmentations);\naddAugmentations(listAugmentations);\naddAugmentations(htmlEventAugmentations);\naddAugmentations(htmlElementAugmentations);\n\nsetNamePrefix(ATTRIBUTE_KEY, getAttribute);\n\nconst create = (root, adapter = HTMLROAdapter) => createRoot(root, adapter);\n\nexport {\n  addAugmentations,\n  resetAugmentations,\n  setNamePrefix,\n  create,\n};\n\nexport default create;\n","export const ATTRIBUTE_KEY = '$';\r\nexport const getAttribute = (node, adapter, [name]) => adapter.getAttributeValue(node, name);\r\n"],"names":["Object","defineProperty","exports","value","defaultAdapter","getDefaultAdapter","namePrefixes","isValidPrefix","prefix","length","hasOwnProperty","isPrefixedKey","key","charAt","getPrefixHandler","isIntKey","parseInt","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","isList","getNodeAt","getNodeList","toList","augmentations","addAugmentations","augs","assign","hasAugmentation","handlers","utils","wrapWithProxy","isNode","Proxy","TreeWalker","Error","createWalkerNode","get","handler","substr","has","hasChild","apply","thisArg","argumentsList","args","applyAugmentation","coreAugmentations","toString","valueOf","[object Object]","Symbol","toPrimitive","children","list","getChildren","childAt","index","getChildAt","root","getNodeRoot","parent","getNodeParent","getLength","first","result","filter","callback","wrappedNode","child","push","map","wrapNodes","areNodes","reduce","create","validateRoot","eventType","toNode","addEventListener","removeEventListener","event","dispatchEvent","Event","String","getName","getText","getAttributes","queryString","querySelector","querySelectorAll","Array","HTMLCollection","NodeList","part","call","HTMLElement","name","toLowerCase","nodeName","childElementCount","hasAttributes","attributes","hasAttribute","getAttribute","innerText","parentNode","getRootNode","document","firstElementChild","nodeAugmentations","listAugmentations","htmlEventAugmentations","htmlElementAugmentations","getAttributeValue","HTMLROAdapter","createRoot"],"mappings":"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"}