{"version":3,"file":"dom-walker.min.js","sources":["../node_modules/tree-walker/dist/tree-walker.js","../source/augmentations/event.js","../source/augmentations/list.js","../source/augmentations/node.js","../source/htmlro-adapter.js","../source/index.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.TreeWalker = {})));\n}(this, (function (exports) { 'use strict';\n\n  let defaultAdapter = null;\n\n  const setDefaultAdapter = adapter => {\n    defaultAdapter = adapter;\n  };\n  const getDefaultAdapter = () => defaultAdapter;\n\n  const namePrefixes = {};\n\n  const isValidPrefix = prefix => typeof prefix === 'string' && prefix.length === 1 && namePrefixes.hasOwnProperty(prefix);\n\n  const isPrefixedKey = key => key && typeof key === 'string' && key.length > 1 && namePrefixes.hasOwnProperty(key.charAt());\n\n  const getPrefixHandler = key => namePrefixes[key.charAt()];\n\n  const setNamePrefix = (prefix, handler) => {\n    if (typeof prefix !== 'string' || prefix.length !== 1) {\n      throw new Error('Name Prefix must be one character string.');\n    }\n\n    namePrefixes[prefix] = handler;\n  };\n\n  const isIntKey = key => `${parseInt(key, 10)}` === key;\n\n  const getValue = (node, adapter, childName = undefined) => {\n    if (childName !== undefined) {\n      return adapter.getChildrenByName(node, childName);\n    }\n\n    return node;\n  };\n\n  const getSingleNode = (node, adapter, childName = undefined) => {\n    const value = getValue(node, adapter, childName);\n\n    if (adapter.isList(value)) {\n      return adapter.getNodeAt(node);\n    }\n\n    return value;\n  };\n\n  const getNodeList = (node, adapter, childName = undefined) => {\n    return adapter.toList(getValue(node, adapter, childName));\n  };\n\n  let augmentations = {};\n\n  const resetAugmentations = (augs = {}) => {\n    augmentations = augs;\n  };\n\n  const addAugmentations = (augs = {}) => {\n    augmentations = Object.assign({}, augmentations, augs);\n  };\n\n  const hasAugmentation = key => key && typeof key === 'string' && augmentations.hasOwnProperty(key);\n\n  const applyAugmentation = (key, ...args) => augmentations[key](...args);\n\n  let handlers;\n  let utils;\n\n  const createWalkerNode = (node, adapter, childName = undefined) => {\n    function TreeWalker() {\n      throw new Error('should have been never called');\n    }\n\n    // can be single Node and NodeList with length >= 0\n    // should it be always NodeList?\n    TreeWalker.node = node;\n    // childName always String/Symbol, Number's are being handled in proxy get wrapper\n    // INFO \"name\" is RO property of Function object\n    TreeWalker.childName = childName;\n    TreeWalker.adapter = adapter;\n    return TreeWalker;\n  };\n\n  const wrapWithProxy = (node, adapter, childName = undefined) => {\n    if (!adapter.isNode(node) && !adapter.isList(node)) {\n      return node;\n    }\n\n    return new Proxy(createWalkerNode(node, adapter, childName), handlers);\n  };\n\n  // eslint-disable-next-line\n  utils = {\n    isIntKey,\n    getValue,\n    getSingleNode,\n    getNodeList,\n    wrapWithProxy\n  };\n\n  const get = ({ node, adapter, childName }, key) => {\n    /*\n     if string childName used\n     if starts with $, return attribute value\n     else return wrapper with current single node and property childName\n     if numeric index used, use node as parent and childName is undefined\n     */\n    if (isIntKey(key)) {\n      return wrapWithProxy(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\n    }\n\n    if (isPrefixedKey(key)) {\n      const handler = getPrefixHandler(key);\n      return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n    }\n\n    // return wrap with node and childName\n    return wrapWithProxy(getValue(node, adapter, childName), adapter, key);\n  };\n\n  const has = ({ node, adapter, childName }, key) => {\n    if (isIntKey(key)) {\n      return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\n    }\n\n    if (isPrefixedKey(key)) {\n      // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\n      // don't know how to implement this, calling same handler as in GET seems overkill\n      return true;\n    }\n\n    return adapter.hasChild(getSingleNode(), key);\n  };\n\n  const apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\n    if (childName === undefined) {\n      throw new Error('Cannot call on TreeWalker Node');\n    }\n\n    // this works only of childName === prefix, one char string\n    // otherwise it should be passed into arguments\n    if (isValidPrefix(childName)) {\n      const handler = getPrefixHandler(childName);\n      return handler(node, adapter, argumentsList, utils);\n    }\n\n    if (hasAugmentation(childName)) {\n      // INFO cannot use target because it contains method's childName, not Node childName\n      // call the function with saving context, so other augmentations are accessible via \"this\"\n      return applyAugmentation(childName, node, adapter, argumentsList, utils);\n    }\n\n    // FIXME might throw only in dev mode(needs implmentation)\n    throw new Error(`\"${childName}\" is not a callable object.`);\n  };\n\n  handlers = {\n    get,\n    has,\n    apply\n  };\n\n  const toString = node => node.toString();\n  const valueOf = node => node;\n\n  var coreAugmentations = {\n    toString,\n    valueOf,\n    [Symbol.toPrimitive]: node => node\n  };\n\n  addAugmentations(coreAugmentations);\n\n  const create = (root, adapter = getDefaultAdapter()) => wrapWithProxy(adapter.validateRoot(root), adapter);\n\n  exports.setDefaultAdapter = setDefaultAdapter;\n  exports.getDefaultAdapter = getDefaultAdapter;\n  exports.addAugmentations = addAugmentations;\n  exports.hasAugmentation = hasAugmentation;\n  exports.resetAugmentations = resetAugmentations;\n  exports.coreAugmentations = coreAugmentations;\n  exports.setNamePrefix = setNamePrefix;\n  exports.isValidPrefix = isValidPrefix;\n  exports.create = create;\n  exports.default = create;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=tree-walker.js.map\n","const on = (node, adapter, [ eventType, callback ], utils) => {\r\n  // add even listener\r\n};\r\n\r\nconst off = (node, adapter, [ eventType, callback ], utils) => {\r\n  // remove even listener\r\n};\r\n\r\nconst emmit = (node, adapter, [ event ], utils) => {\r\n  // dispatch event\r\n};\r\n\r\nexport default {\r\n  on,\r\n  off,\r\n  emmit,\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => {\r\n\r\n};\r\n\r\nconst filter = (node, adapter, [ callback ], utils) => {\r\n  // apply filter on element collection\r\n  // allways return wrapped HTMLCollection\r\n};\r\n\r\nconst map = (node, adapter, [ callback, wrapNodes = true ], utils) => {\r\n  // apply map on element collection\r\n  // if wrapNodes in FALSE, will generate normal Array with RAW results in it\r\n  // if wrapNodes in TRUE, will generate wrapped HTMLCollection and put all result into it\r\n};\r\n\r\nconst reduce = (node, adapter, [ callback, head ], utils) => {\r\n  // apply reduce on element collection\r\n};\r\n\r\nexport default {\r\n  length,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce,\r\n};\r\n","const name = (node, adapter, args, utils) =>\r\n  adapter.getName(utils.getSingleNode(node, adapter));\r\n\r\nconst text = (node, adapter) =>\r\n  adapter.getText(node);\r\n\r\nconst children = (node, adapter, [childName], utils) => {\r\n  node = utils.getSingleNode(node, adapter);\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrapWithProxy(list, adapter);\r\n};\r\n\r\n// FIXME move parts to adapter\r\nconst attributes = (node, adapter, args, utils) => {\r\n  const target = utils.getSingleNode(node, adapter);\r\n  if (target.hasAttributes()) {\r\n    return target.attributes;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// FIXME move parts to adapter\r\nconst attribute = (node, adapter, [attrName], utils) => {\r\n  const attrs = attributes(node, adapter, [], utils);\r\n  if (attrs) {\r\n    const attr = attrs.getNamedItem(attrName);\r\n    if (attr) {\r\n      return attr.value;\r\n    }\r\n  }\r\n  return '';\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  adapter.getChildAt(utils.getSingleNode(node, adapter), index);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrapWithProxy(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrapWithProxy(adapter.getNodeParent(node), adapter);\r\n\r\nconst query = (node, adapter, [queryString], utils) => {\r\n\r\n};\r\n\r\nconst queryAll = (node, adapter, [queryString], utils) => {\r\n\r\n};\r\n\r\nexport default {\r\n  name,\r\n  text,\r\n  children,\r\n  attributes,\r\n  attribute,\r\n  childAt,\r\n  root,\r\n  parent,\r\n  query,\r\n  queryAll,\r\n};\r\n","const isList = (node) => node instanceof HTMLCollection || node instanceof Array;\r\n\r\nconst toList = (...args) => {\r\n  const { length } = args;\r\n  const [node] = args;\r\n\r\n  if (length === 1 && isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    const part = args[index];\r\n    if (isList(part)) {\r\n      list.push.call(part);\r\n    } else {\r\n      list.push(part);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst isNode = (node) => node instanceof HTMLElement;\r\n\r\nconst toNode = (node) => {\r\n  // if list we use only first node\r\n  if (isList(node)) {\r\n    return node.length ? node[0] : null;\r\n  }\r\n\r\n  return isNode(node) ? node : null;\r\n};\r\n\r\nconst getNodeAt = (list, index = 0) => {\r\n  if (isList(list)) {\r\n    return list[index];\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst getLength = (list) => list.length;\r\n\r\n// Node\r\nconst getChildren = (node) => {\r\n  node = toNode(node);\r\n\r\n  // if not a node, return empty list\r\n  return isNode(node) ? node.children : toList();\r\n};\r\n\r\nconst getChildrenByName = (node, name) => {\r\n  name = name.toLowerCase();\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  if (!length) {\r\n    return children;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < children.length; index++) {\r\n    const child = children[index];\r\n    if (child.nodeName.toLowerCase() === name) {\r\n      list.push(child);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst hasChildren = (node) => !!toNode(node).childElementCount;\r\n\r\nconst hasChild = (node, name) => {\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    if (children[index].nodeName === name) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst getChildAt = (node, index) => getChildren(node)[index];\r\n\r\nconst hasAttribute = (node, name) => toNode(node).hasAttribute(name);\r\n\r\nconst getAttributeValue = (node, name) => toNode(node).getAttribute(name);\r\n\r\nconst getName = (node) => toNode(node).nodeName;\r\n\r\nconst getText = (node) => toNode(node).innerText;\r\n\r\nconst getNodeParent = (node) => toNode(node).parentNode;\r\n\r\nconst getNodeRoot = (node) => toNode(node).getRootNode();\r\n\r\nconst validateRoot = (root) => {\r\n  if (root === undefined || root === document) {\r\n    return document.firstElementChild;\r\n  } else if (typeof root === 'string') {\r\n    return document.querySelector(root);\r\n  }\r\n\r\n  return root;\r\n};\r\n\r\nexport default {\r\n  isList,\r\n  toList,\r\n  isNode,\r\n  getNodeAt,\r\n  getLength,\r\n  getChildren,\r\n  getChildrenByName,\r\n  hasChildren,\r\n  hasChild,\r\n  getChildAt,\r\n  hasAttribute,\r\n  getAttributeValue,\r\n  getName,\r\n  getText,\r\n  getNodeParent,\r\n  getNodeRoot,\r\n  validateRoot,\r\n};\r\n","import {\n  setNamePrefix,\n  setDefaultAdapter,\n  addAugmentations,\n  resetAugmentations,\n  coreAugmentations,\n  create as createRoot,\n} from 'tree-walker';\n\nimport htmlEventAugmentations from './augmentations/event';\nimport htmlListAugmentations from './augmentations/list';\nimport htmlNodeAugmentations from './augmentations/node';\n\nimport HTMLROAdapter from './htmlro-adapter';\n\nconst ATTRIBUTE_KEY = '$';\n\nsetDefaultAdapter(HTMLROAdapter);\n\naddAugmentations(coreAugmentations);\naddAugmentations(htmlNodeAugmentations);\naddAugmentations(htmlListAugmentations);\naddAugmentations(htmlEventAugmentations);\n\nsetNamePrefix(ATTRIBUTE_KEY, (node, adapter, [name]) => adapter.getAttributeValue(node, name));\n\nconst create = (root, adapter = HTMLROAdapter) => createRoot(root, adapter);\n\nexport {\n  addAugmentations,\n  resetAugmentations,\n  setNamePrefix,\n  create,\n};\n\nexport default create;\n"],"names":["exports","defaultAdapter","getDefaultAdapter","namePrefixes","isValidPrefix","prefix","length","hasOwnProperty","isPrefixedKey","key","charAt","getPrefixHandler","isIntKey","parseInt","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","value","isList","getNodeAt","getNodeList","toList","augmentations","addAugmentations","augs","Object","assign","hasAugmentation","handlers","utils","wrapWithProxy","isNode","Proxy","TreeWalker","Error","createWalkerNode","get","handler","substr","has","hasChild","apply","thisArg","argumentsList","args","applyAugmentation","coreAugmentations","toString","valueOf","[object Object]","Symbol","toPrimitive","create","root","validateRoot","setDefaultAdapter","resetAugmentations","setNamePrefix","default","defineProperty","factory","eventType","callback","event","getLength","wrapNodes","head","attributes","target","hasAttributes","getName","getText","list","getChildren","attrName","attrs","attr","getNamedItem","index","getChildAt","getNodeRoot","getNodeParent","queryString","HTMLCollection","Array","part","push","call","HTMLElement","toNode","children","name","toLowerCase","child","nodeName","childElementCount","hasAttribute","getAttribute","innerText","parentNode","getRootNode","document","firstElementChild","querySelector","HTMLROAdapter","htmlNodeAugmentations","htmlListAugmentations","htmlEventAugmentations","getAttributeValue","createRoot"],"mappings":"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"}